

#DFS #BFS

# π κ·Έλν”„ νƒμƒ‰ λ°©λ²•
λΉ„μ„ ν• κµ¬μ΅°μΈ κ·Έλν”„ κµ¬μ΅°λ” ν‘ν„λ λ¨λ“  μλ£λ¥Ό λΉ μ§μ—†μ΄ νƒμƒ‰ν•λ” κ²ƒμ΄ μ¤‘μ”ν•λ‹¤.
κ·Έλμ„ μ•„λμ™€ κ°™μ€ νƒμƒ‰ κΈ°λ²μ΄ μ΅΄μ¬ν•λ‹¤.

|DFS|BFS|
|---|---|
|stack ν™μ©|ν ν™μ©|


## DFS
stack ν™μ©
- λ‚΄κ°€ λ‹¤μ‹ λμ•„μ¬ κ³³μ„ μ €μ¥ν•κΈ° μ„ν•΄ μ¤νƒμ„ μ΄μ©ν•λ‹¤.
- **κ°€μ¥ λ§μ§€λ§‰μ— λ§λ‚¬λ κ°λ¦ΌκΈΈ κ°„μ„ μ΄ μλ” μ •μ μΌλ΅ λλμ•„**μ™€μ„ λ‹¤λ¥Έ λ°©ν–¥μ μ •μ μΌλ΅ κ³„μ† λ°λ³µ νƒμƒ‰ν•μ—¬ λ¨λ“  μ •μ μ„ νƒμƒ‰ ν•λ‹¤.
- μ¤νƒμ ν›„μ…μ„ μ¶ κµ¬μ΅° OR μ¬κ·€ νΈμ¶μ„ μ΄μ©ν•μ—¬ κµ¬ν„
	- λ°±νΈλν‚Ήμ„ ν†µν•΄ λ›°μ–΄λ‚ ν¨μ©μ„ λ³΄μΈλ‹¤.
- μΈμ ‘ ν–‰λ ¬(Adjacency Matrix)
	- μΈμ ‘ ν–‰λ ¬μ€ λ©”λ¨λ¦¬ λ‚­λΉ„κ°€ μ‹¬ν•λ‹¤. λ€μ•μ€?
- μΈμ  λ¦¬μ¤νΈ(Adjacency List)
```
graph = {
	1: [2, 3, 4],
	2: [5],
	3: [5],
	4: [],
	5: [6, 7],
	6: [],
	7: [3],
}
```


1. μ¬κ·€ κµ¬μ΅°λ΅ κµ¬ν„
μΌλ°μ μΌλ΅ DFSλ” μ¤νƒμΌλ΅ κµ¬ν„ν•λ©°, μ¬κ·€λ¥Ό μ΄μ©ν•λ©΄ μΆ€ κ°„λ‹¨ν•κ² κµ¬ν„ν•  μ μλ‹¤. μ½”λ”© ν…μ¤νΈ μ‹μ—λ„ μ¬κ·€ κµ¬ν„μ΄ λ” μ„ νΈλλ” νΈμ΄λ‹¤.

μλ„μ½”λ“
```
DFS(G, v)
	label v as discovered
	for all directed edges from v to w that are in G.adjacentEdges(v) do
		if vertex w is not labeled as discovered then recursively call DFS(G,w)
```


```python
# μ¬κ·€λ΅ ν‘ν„ν• DFS


# arrμ€ μΈμ ‘ν–‰λ ¬
# visited λ¦¬μ¤νΈλ” λ°©λ¬Έν–λ”μ§€ κΈ°λ΅
def DFS(v):    # μ…λ ¥ νλΌλ―Έν„°: νƒμƒ‰ μ‹μ‘μ •μ  v
	visited[v] = 1
	print(v, end=" ")
	# μΈμ ‘ν• μ •μ  μ¤‘ λ°©λ¬Έμ„ μ•ν• κ³³ νƒμƒ‰
	for w in range(1, V+1):
		if arr[v][w] == 1 and visited[w] == 0:    # vμ— μΈμ ‘ν•΄ μκ³  λ°©λ¬Έν•μ§€ μ•μ€ κ²½μ°
			dfs(w)                                # μ¬κ·€

```

```python
# λ°λ³µλ¬ΈμΌλ΅ dfs κµ¬ν„ν•κΈ°

def DFS(v):    # μ…λ ¥ νλΌλ―Έν„°: νƒμƒ‰ μ‹μ‘μ •μ  v
	stack = [v]
	while len(stack):   # μ¤νƒμ΄ λΉ„μ§€ μ•μ€ κ²½μ°
		v = stack.pop()
		visited[v] = 1  # λ°©λ¬Έν–μμ„ ν‘μ‹
		for w in range(1, V + 1):
			if arr[v][w] == 1 and visited[w] == 0:    # vμ— μΈμ ‘ν•΄ μκ³  λ°©λ¬Έν•μ§€ μ•μ€ κ²½μ°
				stack.append(w)                       # μ¤νƒμ— ν‘Έμ‰¬

```



## BFS

Queue ν™μ©
- μ‹μ‘μ μ μΈμ ‘ν• μ •μ λ“¤μ„ λ¨λ‘ μ°¨λ΅€λ΅ λ°©λ¬Έν• ν›„ λ°©λ¬Έν–λ μ •μ μ„ μ‹μ‘μ μΌλ΅ ν•μ—¬ λ‹¤μ‹ μΈμ ‘ν• μ •μ λ“¤μ„ μ°¨λ΅€λ΅ λ°©λ¬Έν•λ” λ°©μ‹
- **μΈμ ‘ν• μ •μ λ“¤μ„ νƒμƒ‰**ν• ν›„, μ°¨λ΅€λ΅ λ„λΉ„ μ°μ„  νƒμƒ‰μ„ μ§„ν–‰ν•΄μ•Ό ν•λ―€λ΅, **μ„ μ…μ„ μ¶** ν•νƒμ μλ£κµ¬μ΅°μΈ ν ν™
	- κ·Έλν”„μ μµλ‹¨ κ²½λ΅λ¥Ό κµ¬ν•λ” λ¬Έμ 

```python

# visited λ¦¬μ¤νΈλ” λ°©λ¬Έν–λ”μ§€ κΈ°λ΅
# queue λ„λΉ„μ°μ„ νƒμƒ‰μ μ§„ν–‰ μƒν™©μ„ μ €μ¥
def BFS(G, v): # μ…λ ¥ νλΌλ―Έν„°: κ·Έλν”„ G, νƒμƒ‰ μ‹μ‘μ  v
    visited = [0] * n # n: μ •μ μ κ°μ
	queue = []        # ν μƒμ„±
	queue.append(v)   # μ‹μ‘μ  vλ¥Ό νμ— μ‚½μ…
	while queue:      # νκ°€ λΉ„μ–΄μμ§€ μ•μ€ κ²½μ°
		t = queue.pop()   # νμ μ²«λ²μ§Έ μ›μ† λ°ν™
		if not visited[t] # λ°©λ¬Έλμ§€ μ•μ€ κ³³μ΄λΌλ©΄
			visited[t] = Treu # λ°©λ¬Έν• κ²ƒμΌλ΅ ν‘μ‹
			visit(t)
		for i in G[t]:    # tμ™€ μ—°κ²°λ λ¨λ“  μ„ μ— λ€ν•΄
			if not visited[i]: # λ°©λ¬Έλμ§€ μ•μ€ κ³³μ΄λΌλ©΄
			queue.append(i)    # νμ— λ„£κΈ°

```